# JVM笔记
## JVM加载Class文件的原理机制

----
Java中所有的类都需要由类加载器加载到JVM中才能运行.类加载器本身也是也是一个类,而它的工作就是把class文件从硬盘读取到内存中,在写程序的时候,我们几乎不需要关心类的加载,因为这些都是隐式加载的.除非我们有特殊的需求,比如映射,就需要显示加载所需要的类.  
Java类的加载是动态的,它并不会一次性加载完所有的类,而是保证加载完成程序运行的基本类.至于其他类,则是在需要的时候才进行加载.  
Java类加载器有三个,就对应Java的三种类:  
> BootstrapLoader => 负责加载系统类(指的是内置类,像是String类)--负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类
>> ExtClassLoader => 负责加载扩展类(就是继承类和实现类)
>>> AppClassLoader => 负责加载应用类(程序自定的类)  

Java采用**委托模型机制**:  
双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成.
![委托模型机制](image/1.jpg) 
```
public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
 
    protected synchronized Class<?> loadClass(String name, boolean resolve)
            throws ClassNotFoundException {
 
        // 首先判断该类型是否已经被加载
        Class c = findLoadedClass(name);
        if (c == null) {
            //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载
            try {
                if (parent != null) {
                    //如果存在父类加载器，就委派给父类加载器加载
                    c = parent.loadClass(name, false);
                } else {
                    //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，
                    //通过调用本地方法native findBootstrapClass0(String name)
                    c = findBootstrapClass0(name);
                }
            } catch (ClassNotFoundException e) {
                // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能
                c = findClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
``` 
 双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改.
#####注意:Java在逻辑上并不存在BootstrapLoader的实体(由C++实现，不是ClassLoader子类) #####
Java采用**缓存机制**:  
缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因.  
### 原理机制
![原理机制](image/2.png)  
  类加载的生命周期包括以下几个部分：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）,其中验证、准备、解析三个部分统称链接.  
  加载（装载）、验证、准备、初始化和卸载这五个阶段顺序是固定的，类加载过程必须按照这种顺序开始，而解析阶段不一定，它在某些情况下可以在初始化之后再开始，这是为了运行时动态绑定特性（JIT例如接口只在调用的时候才知道具体的实现的是哪个子类）。值得注意的是：这些阶段通常都是交叉的混合式进行的，通常会在一个阶段执行的过程中调用或激活另一个阶段.  
 #### 加载
   加载这个阶段通常也被称为"装载"，它的主要任务主要有一下几点：  

     1、通过"类全名"来获取定义此类的二进制字节流  
     2、将字节流所代表的静态存储结构转换为方法区的运行时数据结构  
     3、在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口  
 
   相对于类加载过程的其他阶段，加载阶段是通过类加载（ClassLoader）来完成的，而类加载器也可以由用户自定义完成，因此，开发人员可以通过定义类加载器去控制字节流的获取方式。加载之后，二进制文件会被读入到虚拟机所需的格式存储在方法区中，方法区中存储格式由虚拟机自行定义，然后在java堆中实例化一个java.lang.Class类对象，通过这个对象就可以访问方法区中的数据  
 #### 验证
   验证阶段是链接阶段的第一步，目的就是确保class文件的字节流中包含的信息符合虚拟机的要求，不能危害虚拟机自身安全。验证阶段主要包括四个检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证  
    
    1、文件格式验证
       验证class文件格式规
    2、元数据验证
       就是对字节码描述的信息进行语义分析，保证描述的信息符合java语言规范。验证点可能包括这个类是否有父类（除Object）、这个类是否继承了不允许被继承的类（final修饰的）、如果这个类的父类是抽象类，是否实现了父类或接口中要求实现的方法
    3、字节码验证
       进行数据流和控制流分析，这个阶段对类的方法体进行校验，保证被校验的方法在运行时不会做出危害虚拟机的行为
    4、符号引用验证
       符号引用中通过字符串描述的权限定名是否能找到对应的类、符号引用类中的类，字段和方法的访问性（private protected public default）是否能被当前类访问  
   


