# HashMap笔记
## HashMap的数据结构
哈希表结构(**链表散列:数组+链表形式**)实现,结合数组和链表的优点.当链表的长度超过8时,链表转换为红黑树
```
transient Node<K,V>\[\] table
```
## HashMap的工作原理
HashMap 底层是 hash 数组和单向链表实现,数组中的每个元素都是链表,由Node(实现Map.Entry接口)内部实现,HashMap通过get/put方法取值/存值  
### PUT方法工作原理
存储对象时，将 K/V 键值传给 put() 方法  
   
    1 调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标  
    
    2 调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）  
     
    3 如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞;如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对;  
      如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对  
      如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）
### GET方法的工作原理
获取对象时，将 K 传给 get() 方法  
     
     1 调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标  
     
     2 顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值  
     
 **hashCode 是定位的，存储位置；equals是定性的，比较两者是否相等**
## HashCode相同的情况
因为 hashCode 相同，不一定就是相等的（equals方法比较），所以两个对象所在数组的下标相同，"碰撞"就此发生。又因为 HashMap 使用链表存储对象，这个 Node 会存储到链表中。  
## Hash的实现
JDK 1.8 中，是通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度，功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞  
**使用异或的原因** 保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞
## HashMap 的 table 的容量如何确定？loadFactor 是什么？该容量如何变化？这种变化会带来什么问题？
      
      1 table 数组大小是由 capacity 这个参数确定的，默认是16，也可以构造时传入，最大限制是1<<30
      
      2 loadFactor 是装载因子，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容  
      
      3 扩容时，调用 resize() 方法，将 table 长度变为原来的两倍（注意是 table 长度，而不是 threshold）  
      
      4 如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命  
      
## 数组扩容过程
  创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种，原下标位置或原下标+旧数组的大小
## 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢  
而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢  
